= Construction d'une librairie d'utilitaires utilisant l'AOP
:tip-caption: üí°
:note-caption: ‚ÑπÔ∏è
:warning-caption: ‚ö†Ô∏è
:icons: font
:hardbreaks-option:

Pr√©fix√© par ‚úîÔ∏è, des "checkpoints" pour vous aider √† v√©rifier que vous avez tout bon.

== Objectif

Utiliser la programmation orient√©e aspect (**A**spect **O**riented **P**rogrammation) pour construire une biblioth√®que d'utilitaires r√©utilisables.

== Pr√©requis

* Git
* Java 21
* Maven 3.9.x
* (Optionnel, mais fortement recommand√©) IntelliJ edition _community_ 2024

'''

* Sur la page du template https://github.com/lernejo/maven-starter-template, cliquer sur "Use this template"
* ‚ö†Ô∏è Renseigner comme nom de d√©p√¥t : *java_aop_training*
* Marquer le futur d√©p√¥t comme *private*
* Une fois le d√©p√¥t cr√©√©, installer l'app https://github.com/apps/korekto[Korekto], ou mettre √† jour sa configuration afin qu'elle ait acc√®s √† ce nouveau d√©p√¥t
* Cloner le d√©p√¥t en utilisant l'*url SSH*
* La branche par d√©faut est la branche `main`, vous √™tes libre de faire des https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/creating-a-pull-request[Pull Requests], mais seule la branche `main` sera corrig√©e.

== Partie 1 - Dynamic Proxy

Dans un premier temps, nous allons cr√©er une impl√©mentation d'une fonction de r√©essaie utilisant un proxy dynamique.

Le but √©tant de cr√©er une instance qui supportera un certain nombre d'erreur pour les m√©thodes correctement annot√©es.


* Cr√©er une nouvelle annotation `fr.lernejo.aop.Retry`
* Cette annotation aura deux param√®tres :
** `maxTries` de type `int` et de valeur par d√©faut `1`
** `errorTypes` de type `Class<? extends Exception>[]`
* Dans le r√©pertoire de test, cr√©er une classe `fr.lernejo.aop.FallibleApi`
* ‚úîÔ∏è V√©rifier que l'annotation est utilisable sur une m√©thode et uniquement sur une m√©thode, en annotant une m√©thode de cette derni√®re classe

* Cr√©er une classe `fr.lernejo.aop.RetryableFactory`
* Y ajouter une m√©thode publique statique `buildRetryable` prenant en param√®tre un param√®tre de type `Class<T>` (g√©n√©rique) et retournera une instance de type `T` (g√©n√©rique)
* Cette instance sera cr√©√©e gr√¢ce √† `javassist.util.proxy.ProxyFactory`
* Les impl√©mentations de `javassist.util.proxy.MethodFilter` et `javassist.util.proxy.MethodHandler` seront dans des classes √† cr√©er dans le m√™me package
* Impl√©menter `javassist.util.proxy.MethodFilter` de mani√®re √† ce que seule les m√©thodes publiques annot√©es avec `@Retry` soient consid√©r√©es
* Impl√©menter `javassist.util.proxy.MethodHandler` de mani√®re √† ce qu'un appel de m√©thode soit r√©p√©t√©e maximum `maxErrorCount` en cas d'erreur
* Si `errorTypes` est vide, d√©clencher le m√©canisme sur `java.lang.Exception` et toutes ses sous-classes
* Sinon d√©clencher le m√©canisme uniquement sur les types sp√©cifi√©s ainsi que tous leurs sous-types
* Si la m√©thode d√©l√©gu√©e sort en erreur alors que le m√©canisme est dans la derni√®re boucle de r√©√©ssaie, lancer la derni√®re erreur obtenue
* Ces diff√©rents cas doivent √™tre test√©s avec des tests unitaires, en profitant de la classe `fr.lernejo.aop.FallibleApi` comme impl√©mentation de test pour d√©crire les diff√©rents cas possibles
* ‚úîÔ∏è V√©rifier que 100% de votre code est test√©




== Partie 2 - Spring AOP

Cr√©er un aspect permettant d'enregistrer le nombre d'appels des m√©thodes publiques.

* Cr√©er une classe publique `fr.lernejo.aop.InvocationTracker`
** cette classe aura (au moins) deux m√©thodes publiques :
[source,java]
----
public static List<String> detectedMethods() {
    // returns the list of recorded methods
}

/**
 * @param methodQualifiedName of the format packageName.className#methodName, example: {@code fr.lernejo.aop.ServiceA#doSomething}
 */
public static long getInvocationCount(String methodQualifiedName) {
    // returns the number of invocation of the given method, 0 if the method is not known
}
----

* Cr√©er une classe publique `fr.lernejo.aop.CountingAspect`
** Cette classe doit √™tre annot√©e avec `org.aspectj.lang.annotation.Aspect`
** Cette classe doit d√©finir un https://docs.spring.io/spring-framework/reference/core/aop/ataspectj/pointcuts.html[pointcut] (`@Pointcut`) ciblant toutes les methodes publiques
** Cette classe doit d√©finir un https://docs.spring.io/spring-framework/reference/core/aop/ataspectj/advice.html[advice] de type `@After` qui incr√©mentera le compteur d'invocation
* Le lien entre ces deux classes se fera via une m√©thode statique
* Tester le bon fonctionnement de cet aspect demandera :
** Une https://docs.spring.io/spring-framework/reference/core/beans/java/composing-configuration-classes.html[configuration] Spring
** Des beans Spring ayant des m√©thodes publiques
** D'utiliser `org.springframework.context.annotation.AnnotationConfigApplicationContext` afin de cr√©er un contexte utilisant la configuration de test pr√©alablement cr√©√©e et de r√©cup√©rer les beans afin d'invoquer leurs m√©thodes publiques

